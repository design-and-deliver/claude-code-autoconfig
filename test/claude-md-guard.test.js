#!/usr/bin/env node

/**
 * Tests for claude-md-guard.js hook
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const HOOK_PATH = path.join(__dirname, '..', '.claude', 'hooks', 'claude-md-guard.js');

// Test utilities
let testDir;
let passed = 0;
let failed = 0;

function setup() {
  testDir = path.join(__dirname, '.test-temp-' + Date.now());
  fs.mkdirSync(testDir, { recursive: true });
  fs.mkdirSync(path.join(testDir, '.claude', 'feedback'), { recursive: true });
}

function cleanup() {
  if (testDir && fs.existsSync(testDir)) {
    fs.rmSync(testDir, { recursive: true });
  }
}

function test(name, fn) {
  try {
    fn();
    console.log(`✓ ${name}`);
    passed++;
  } catch (err) {
    console.log(`✗ ${name}`);
    console.log(`  Error: ${err.message}`);
    failed++;
  }
}

function assertEqual(actual, expected, msg = '') {
  if (actual !== expected) {
    throw new Error(`${msg} Expected "${expected}", got "${actual}"`);
  }
}

function assertIncludes(str, substr, msg = '') {
  if (!str.includes(substr)) {
    throw new Error(`${msg} Expected string to include "${substr}"`);
  }
}

function assertExists(filePath, msg = '') {
  if (!fs.existsSync(filePath)) {
    throw new Error(`${msg} Expected file to exist: ${filePath}`);
  }
}

// Run hook with simulated input
function runHook(input) {
  const inputJson = JSON.stringify(input);
  try {
    const result = execSync(`node "${HOOK_PATH}"`, {
      input: inputJson,
      encoding: 'utf8',
      cwd: testDir,
      timeout: 5000
    });
    return { output: result, exitCode: 0 };
  } catch (err) {
    return { output: err.stdout || '', exitCode: err.status || 0 };
  }
}

// =============================================================================
// TESTS
// =============================================================================

console.log('============================================================');
console.log('CLAUDE-MD-GUARD HOOK TESTS');
console.log('============================================================');
console.log();

// -----------------------------------------------------------------------------
// Timestamp Parsing Tests
// -----------------------------------------------------------------------------

console.log('Timestamp Parsing:');

test('Parses valid timestamp from header', () => {
  // Test the regex pattern used in the hook (human-readable format)
  const content = '<!-- AUTO-GENERATED BY /autoconfig at 2026-01-14 16:30:45 UTC — Do not edit. -->';
  const match = content.match(/AUTO-GENERATED.*?at\s+(\d{4}-\d{2}-\d{2}\s+[\d:]+)\s+UTC/);
  assertEqual(match !== null, true, 'Should match timestamp pattern');
  assertEqual(match[1], '2026-01-14 16:30:45', 'Should extract correct timestamp');
});

test('Handles timestamp with different times', () => {
  const content = '<!-- AUTO-GENERATED BY /autoconfig at 2025-12-31 23:59:59 UTC — Do not edit. -->';
  const match = content.match(/AUTO-GENERATED.*?at\s+(\d{4}-\d{2}-\d{2}\s+[\d:]+)\s+UTC/);
  assertEqual(match[1], '2025-12-31 23:59:59');
});

test('Returns null for missing timestamp', () => {
  const content = '<!-- AUTO-GENERATED BY /autoconfig — Do not edit. -->';
  const match = content.match(/AUTO-GENERATED.*?at\s+(\d{4}-\d{2}-\d{2}\s+[\d:]+)\s+UTC/);
  assertEqual(match, null, 'Should not match without timestamp');
});

test('Returns null for non-autoconfig content', () => {
  const content = '# My Project\n\nSome content here';
  const match = content.match(/AUTO-GENERATED.*?at\s+(\d{4}-\d{2}-\d{2}\s+[\d:]+)\s+UTC/);
  assertEqual(match, null);
});

console.log();

// -----------------------------------------------------------------------------
// Integration Tests (with temp files)
// -----------------------------------------------------------------------------

console.log('Integration Tests:');

setup();

test('Allows system edit (within 3s of timestamp)', () => {
  const now = new Date();
  const timestamp = now.toISOString().replace('T', ' ').substring(0, 19);
  const claudeMdPath = path.join(testDir, 'CLAUDE.md');
  const content = `<!-- AUTO-GENERATED BY /autoconfig at ${timestamp} UTC — Do not edit. -->\n\n# Project\n`;

  fs.writeFileSync(claudeMdPath, content);

  const result = runHook({
    tool_input: { file_path: claudeMdPath }
  });

  // Should exit silently (allowed edit)
  assertEqual(result.output.includes('I noticed you edited'), false, 'Should not show warning for system edit');
});

test('Detects user edit (> 3s after timestamp)', () => {
  // Create fresh temp dir for this test to avoid state from previous test
  const testDir2 = path.join(__dirname, '.test-temp-user-edit-' + Date.now());
  fs.mkdirSync(testDir2, { recursive: true });
  fs.mkdirSync(path.join(testDir2, '.claude', 'feedback'), { recursive: true });

  const oldTime = new Date(Date.now() - 10000); // 10 seconds ago
  const timestamp = oldTime.toISOString().replace('T', ' ').substring(0, 19);
  const claudeMdPath = path.join(testDir2, 'CLAUDE.md');
  const feedbackPath = path.join(testDir2, '.claude', 'feedback', 'FEEDBACK.md');

  const userEditedContent = `<!-- AUTO-GENERATED BY /autoconfig at ${timestamp} UTC — Do not edit. -->\n\n# User Changed This\n`;

  fs.writeFileSync(claudeMdPath, userEditedContent);
  fs.writeFileSync(feedbackPath, '# Feedback\n');

  const result = runHook({
    tool_input: { file_path: claudeMdPath }
  });

  // Should show warning message
  assertIncludes(result.output, 'I noticed you edited', 'Should show warning for user edit');

  // Content should be migrated to FEEDBACK.md
  const feedbackContent = fs.readFileSync(feedbackPath, 'utf8');
  assertIncludes(feedbackContent, 'Manual Edits (auto-captured)', 'Should add migration header');
  assertIncludes(feedbackContent, 'User Changed This', 'Should include user content');

  // Cleanup this test's temp dir
  fs.rmSync(testDir2, { recursive: true });
});

test('Ignores non-CLAUDE.md files', () => {
  const otherFile = path.join(testDir, 'README.md');
  fs.writeFileSync(otherFile, '# README');

  const result = runHook({
    tool_input: { file_path: otherFile }
  });

  // Should exit silently
  assertEqual(result.output, '', 'Should produce no output for non-CLAUDE.md files');
});

test('Ignores files without autoconfig header', () => {
  const claudeMdPath = path.join(testDir, 'CLAUDE.md');
  fs.writeFileSync(claudeMdPath, '# Manual CLAUDE.md\n\nNo autoconfig header here.');

  const result = runHook({
    tool_input: { file_path: claudeMdPath }
  });

  // Should exit silently (not an autoconfig-managed file)
  assertEqual(result.output.includes('I noticed you edited'), false);
});

cleanup();

console.log();

// -----------------------------------------------------------------------------
// Summary
// -----------------------------------------------------------------------------

console.log('============================================================');
if (failed === 0) {
  console.log(`ALL TESTS PASSED (${passed} tests)`);
} else {
  console.log(`TESTS FAILED: ${passed} passed, ${failed} failed`);
  process.exit(1);
}
